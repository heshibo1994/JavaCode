2、Java最大的特点：面向对象的编程设计。
其他：面向过程编程，函数式编程。
面向过程是指面对一个问题的解决方案，更多的情况不会做出重用的设计；
面向对象更加侧重于模块化设计，会考虑到重用配置，对于整个面向对象更多的考虑标准。
特性：
    封装性：内部的操作对外部不可见，当内部的操作都不可直接使用才是安全的。
    继承性：在已有结构基础上再继续进行功能的扩充。
    多态性：是在继承的基础上扩充而来的概念，指的是类型的转化处理。
面向对象程序开发的一般过程：
    OOA：面向对象分析
    OOD：面向对象设计
    OOP：面向对象编程

3、面向对象的核心：类和对象
类是对某一类事物的共性的抽象，对象描述的是一个具体的产物。
类是一个模板，对象是类的一个实例，先有类再有对象。
类的组成：
    成员属性：
    操作方法：定义对象具有的处理行为。方法时可以重复执行的代码
对象的方法和属性都要在类的框架下使用。
产生对象的方法：声明并实例化对象：类名称 对象名称 =  new 类名称()
当获取了类的实例化对象后，就需要通过对象进行类中的操作调用，调用方法有两种
    调用类中的属性：对象.属性
    调用类中的方法：对象.方法（）

5、对象的实例化操作初步分析：
    Java中类属于引用数据类型，引用数据类型需要考虑到内存的管理，在进行操作时也会引起内存的变化
    内存管理：常用的内存空间
        堆内存：保存的是对象的具体信息，在程序之中堆内存的空间开辟通过new来完成。
        栈内存：保存的一块内存的地址，通过地址找到堆内存，再找到对象的内容。
=====
pic1
=====
错误代码：
    Person per1 = null;//声明并实例化对象
    per1.age = 18;
    per1.name = "KeRan";
    per1.tell();
Exception in thread "main" java.lang.NullPointerException
	at classandObject.JavaDemo.main(JavaDemo.java:12)
所有的代码对象必须在调用类中的属性或者方法的时候必须实例化完成后在可以执行。
NullPointerException表示空指向异常，表示在没有堆内存开辟后产生的问题。

6、类属于引用数据类型，同一块堆内存可以被不同的栈内存所指向，也可以跟换指向。
    Person per1 = new Person();//声明并实例化对象
    per1.age = 18;
    per1.name = "KeRan";
    Person per2 = per1;//引用传递
    per2.age = 80 ;
    per1.tell();
以上引用传递是直接在主方法之内的定义的，也可以通过方法实现引用传递。
public static void change(Person temp){
    temp.age = 90;
}
=====
pic2
=====
7、引用与垃圾产生分析
所有的引用传递本质是堆内存的调节，堆内存的调节不当，会产生垃圾。
    Person per1 = new Person();
    Person per2 = new Person();
    per1.age = 20;
    per2.age = 30;
    per2 = per1;
    per1.tell();//30
以上过程也完成了引用传递的过程。
=====
pic3
=====
垃圾空间是指所有没有任何栈内存指向的堆内存空间，所有的垃圾会被GC（垃圾收集器）定期进行回收
并释放无效内存。
8、成员属性封装
在类中的组成为属性和方法，方法一般都是对外提供服务的，所以不会进行封，但是对于属性而言，需要较高的
安全性，一般都需要进行保护，此时就需要采用封装性对属性进行封装。
    Person per = new Person();//声明并实例化对象
    per.age = 18;//per.age = -18;
    per.name = "KeRan";
    per.tell();
以上并没有对name和age两个属性进行封装处理，这样外部就可以直接对属性进行修改，
现在通过private对属性进行封装，那么外部就不可以直接对内部属性进行修改。即对外部不可见，对内部还是可见的。
错误代码：
    public class Person {
        private String name;
        private int age;
        public void tell(){
            System.out.println("name: "+name+"age: "+age);
        }
    }
    public static void main(String[] args) {
        Person per = new Person();//声明并实例化对象
        per.age = 18;
        per.name = "KeRan";
        per.tell();
    }
Error:(6, 12) java: age 在 classandObject.Person 中是 private 访问控制。
如果在实际场景中，需要对类的内部属性进行访问，以setter和getter方法来实现。
类中的属性一般都必须使用private封装。
    public String getName() {return name; }
    public void setName(String name) {this.name = name; }
    public int getAge() {return age;}
    public void setAge(int age) {this.age = age; }
9、构造方法与匿名对象
使用类的时候的一般步骤：
    声明并实例化对象，实例化的对象属性中并没有热呢的数据存在
    通过一系列的setter和getter来进行内容设置。
为了解决对象初始化的问题，通过构造方法来实例化对象中的属性。
构造方法的定义要求：
    构造方法和类型一致；
    无任何返回值；
    构造方法在使用关键字new的实例化对象的时候自动调用；
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    //声明并实例化对象
    Person per = new Person("keren ",18);
在Java程序中会考虑结构的完整性，所有的类都会提供构造方法，如果没有提供构造方法，那么程序会在编译时
自动创造一个无参构造方法，如果明确创造了，默认的构造方法就不会自动创造了。
构造方法为什么没有返回值？
如过构造方法有返回值，那么该方法就会被认为是一个普通方法，构造方法是在类对象实例化的时候调用的
普通方法是在类对象实例化产生之后调用的。
构造方法的重载(方法名相同，参数类型和个数不同)：在对多个构造函数重载时，尽可能按照参数个数来写。
匿名对象：        new Person("apple",29).tell();
该对象没有任何的引用名称，所以对象使用一次以后就将成为垃圾，所有的垃圾被GC进行回收和释放。

10  this关键字
    当前类中的属性：this.属性
            利用构造方法和setter方法都可以对属性进行赋值
            public Person(String name, int age) {
                this.name = name;
                this.age = age;
                }
            在Java中{}作为一个结构体的边界符号，在程序中对变量使用时，都会以{}为查找边界；
            按照就近取用原则，此时构造方法并没有访问类中的属性，因此要加上this来对区分属性
            和参数的区别。
    当前类中的方法：this.方法名称（）
            对构造方法的调用:this（）对于构造方法的调用，放在构造方法中执行
                public Person(){
                        System.out.println("doing something");
                }
                public Person(String name) {
                    this();
                    this.name = name ;
                }
                public Person(String name, int age) {
                    this(name);
                    this.age = age;
                }
                构造方法的this（）只能放在构造方法的首行
                构造方法互相调用时必须保留出口，避免递归调用的问题。
            对普通方法的调用:this.方法（）
12 简单Java类
    描述某一类信息的程序类，在该类中没有特别复杂的逻辑操作，只作为一种信息存储的媒介存在
        类名称有一定的具体的含义
        类中的所有属性必须private进行封装，封装后必须提供setter/getter
        类中可以提供多个构造方法，但必须保留无参构造
        类中不允许出现输出语句，所有内容的获取必须返回
13 声明static属性
    static修饰属性
        在一个类中，属性一旦定义，内容都交由各自的堆内存空间保存，每一个对象保存自己各自的属性。
        当对象的数量极大，就会面临重复保存，修改不方便的问题。
        利用static修饰属性，可以让该属性变成公共属性，一次修改，全部变化。
        public class Person {
            private String name;
            private int age;
            static String country = "中华民国";
        }
        country是一个共同的属性，在修改时最好直接使用类来访问，static属性可以直接由类名直接调用。
            Person p1 = new Person("keran3", 20);
            Person p2 = new Person("keran2", 20);
            Person p3 = new Person("keran1", 20);
            Person.country = "中国";
            System.out.println(p1.toString());
 ===
 pic4
 ===
        static属性可以在没有实例化对象时直接调用，直接通过类的名称调用
            System.out.println(Person.country);
            Person.country = "中国";
            Person p = new Person("keran3", 20);
            System.out.println(p);
    static修饰方法
        static方法可以直接通过类名调用。
        static方法只可以调用static属性或者static方法。
        报错代码
            public static void setCountry(String c) {
                country = c;
                name = "kekeke";
            }
        Error:(15, 9) java: 无法从静态上下文中引用非静态 变量 name
        非static方法可以调用static属性或者static方法。
        所有的static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有的static定义的属性和方法都必须在实例化对象的前提下使用。
16代码块
由{}定义的代码成为代码块
    普通代码块:定义在一个普通方法的代码
        {
            int x = 10;
            System.out.println("x1: "+x);
        }
        int x = 100;
        System.out.println("x2: "+x);
        在Java开发中相同名称的变量不能在同一个方法中存在，但是可以通过{}进行分界。
        可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。
    构造代码块：定义在一个类中的，优先于构造方法先执行
    静态代码块：使用static关键字定义的代码块，静态代码块优先于构造代码块，并且无论有多少个对象初始化都只执行一次。
25数组
一组相关变量的集合，数组的使用会牵扯到内存的分配
    数组的初始化：
        动态初始化：数组的的每个元素为默认值
            数据类型 数组名称 [] = new 数据类型[长度]；
            数据类型 [] 数组名称 = new 数据类型[长度]；
                int data [] = new int [3];
                System.out.println(data[0]);//默认值
                System.out.println(data[3]);//数组越界
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
        静态初始化：在定义时就赋值
            数据类型 数组名称 [] = {N1，N2.......Nn}；
            数据类型 数组名称 [] = new 数据类型 {N1，N2.......Nn}；
    数组的内存分析：
        int data [] = new int [3];
        data[0]  = 10;
        data[1]  = 20;
        data[2]  = 30;
===
pic5
===
        数组也属于引用数据类型,一定也要为其开辟堆内存空间才可以使用（先new）。
            int data [] = new int [] {10,20,30};
            int temp [] = data;
            temp[0] = 99;
            System.out.println(data[0]);
===
pic6
===
    foreach迭代输出，减轻对数组下标的依赖，可以直接将数组的元素放在变量里，避免使用下标的形式获取元素。
    for（数据类型 变量 ：数组|集合）{}
        for(int temp:data){
            System.out.println(temp);
        }
    二维数组：处理多行多列的数组，此时描述一个数据需要行小标和纵下表
        int data[][] = new int[][]{{1, 2, 3}, {2, 3, 4}};
        for (int i = 0; i < data.length; i++)
            for (int j = 0; j < data[i].length; j++) {
                System.out.println(data[i][j]);
            }
        }
    数组和方法：通过方法对数组进行引用传递
        定义方法返回数组，修改数组：
             public static void main(String[] args) {
                int data[] = initArray();
                changeArrat(data);
                printArray(data);
            }

            private static void changeArrat(int[] data) {
                for (int i = 0;i<data.length;i++) data[i] *= 2;
            }
            private static void printArray(int[] data) {
                for (int temp:data){
                    System.out.println(temp);
                }
            }

            private static int[] initArray() {
                int arr [] = new int []{1,2,3,4,5};
                return arr;
            }
===
pic7
===
    数组的相关方法:
        排序：java.util.Arrays.sort(data);
        拷贝：System.arraycopy(源数组，源数组开始点，目标数组，目标数组开始点，拷贝长度)
    方法可变参数：使用这种方法可以避免数组的使用
        public static int sum(int ... data){
            int sum = 0;
            for(int temp:data){
                sum+=temp;
            }
            return sum;
        }
    对象数组：将类作为数据类型
        动态初始化：类 对象数组名  [] = new 类 [长度]
        静态初始化：类 对象数组名  [] = new 类 []{对象1，对象2.......}
            Person per [] = new Person[]{
                new Person("keran",23),
                new Person("keran",24),
                new Person("keran",25),
            };
            for (int i= 0;i<per.length;i++){
                System.out.println(per[i].toString());
            }

35 引用传递
通过面向对象的设计来解决关系转化的问题
    类关联结构
        // 声明对象并设置彼此的关系
        Person person = new Person("keran",24);
        Car car = new Car("SUV",30);
        person.setCar(car);
        car.setPerson(person);
        // 根据关系获取数据
        System.out.println(person.getCar().toString());
        System.out.println(car.getPerson().toString());
    自身关联
        // 声明对象并设置彼此的关系
        Person person = new Person("keran",24);
        Person childA = new Person("a",20);
        Person childB = new Person("b",21);
        childA.setCar(new Car("cara",2));
        childB.setCar(new Car("carb",3));
        Car car = new Car("SUV",30);
        person.setCar(car);
        person.setChildren(new Person[]{childA,childB});
        car.setPerson(person);
        // 根据关系获取数据
        System.out.println(person.getCar().toString());
        System.out.println(car.getPerson().toString());
        for(Person p : person.getChildren()){
            System.out.println(p.toString());
            System.out.println(p.getCar().toString());
        }
    数据表和简单Java类的映射转换
        数据实体表设计 = 类的定义
        表中的字段 = 类的成员属性
        表的外键关联 = 引用实现
        表的一行记录 = 类的一个实例化对象
        表的多行记录 = 对象数组
        程序中只需要考虑实体表的设计，对于中间的访问记录信息表不要求进行转化处理。
        代码实例：用户的授权管理：-----一个用户可以拥有多个角色，一个角色可以有多个用户
                                 -----一个角色可以拥有多个权限
            Member memberA = new Member("alibaba","mema");
            Member memberB = new Member("baidu","memb");
            Role roleA = new Role(1l,"系统配置");
            Role roleB = new Role(2l,"备份管理");
            Role roleC = new Role(3l,"人事管理");
            Privilege priA = new Privilege(1000l,"系统初始化");
            Privilege priB = new Privilege(1001l,"系统还原");
            Privilege priC = new Privilege(1002l,"系统环境修改");
            Privilege priD = new Privilege(2000l,"备份员工数据");
            Privilege priE = new Privilege(2001l,"备份部门数据");
            Privilege priF = new Privilege(2002l,"备份公文数据");
            Privilege priG = new Privilege(3000l,"增加员工");
            Privilege priH = new Privilege(3001l,"编辑员工");
            Privilege priI = new Privilege(3002l,"浏览员工");
            Privilege priJ = new Privilege(3003l,"员工离职");
            //增加角色和权限的对应关系
            roleA.setPrivileges(new Privilege[]{priA,priB,priC});
            roleB.setPrivileges(new Privilege[]{priD,priE,priF});
            roleC.setPrivileges(new Privilege[]{priG,priH,priI,priJ});
            //增加权限与角色对应
            priA.setRole(roleA);
            priB.setRole(roleA);
            priC.setRole(roleA);
            priD.setRole(roleB);
            priE.setRole(roleB);
            priF.setRole(roleB);
            priG.setRole(roleC);
            priH.setRole(roleC);
            priI.setRole(roleC);
            priJ.setRole(roleC);
            //增加用户与角色的对应关系
            memberA.setRoles(new Role[]{roleA,roleB});
            memberB.setRoles(new Role[]{roleA,roleB,roleC});
            roleA.setMembers(new Member[]{memberA,memberB});
            roleB.setMembers(new Member[]{memberA,memberB});
            roleC.setMembers(new Member[]{memberB});
            //输出信息
            System.out.println(memberB.toString());
            for (Role r : memberB.getRoles()){
                System.out.println(r.toString());
                for (Privilege p:r.getPrivileges()){
                    System.out.println(p.toString());
                }
            }
49字符串
在Java中所有的字符串都是用双引号来定义的
String类不是一种基本数据类型，利用JVM的支持制造了一种可以简单实用的S如图ring类
    String的实例化
        直接赋值进行实例化：
            String s =  "hello,keran";
            System.out.println(s);
            利用直接赋值的方法可以实现同一个字符串的共享操作
                    String str1 = "hello";
                    String str2 = "hello";
                    System.out.println(str1 == str2);//true
            在Java的底层中，会提供字符串池,在直接赋值的方法中，对于字符串可以实现池数据的诸佛能够保存
            如果有相同的数据定义时，可以减少定义，实现对象的重用，提升性能
        利用构造方法进行实例化：
            String ss = new String("keran,hello");
            System.out.println(ss);
            String sstr1 = new String("hello");
            String sstr2 = new String("hello");
            System.out.println(sstr1 == sstr2);//false
            不会自动入池，可以手动使用intern()入池
            String sstr1 = new String("hello").intern();
            String sstr2 = new String("hello").intern();
            System.out.println(sstr1 == sstr2);//true
        String源码分析：
        String 类之所以可以保存字符串主要是因为其中定义了一个数组，String中的每一个字符都保存在数组中
        JDK1.9开始开始String中的保存的是字节数组
                private final byte[] value;
    String字符串比较
            String s =  "hello,keran";
            String ss = new String("keran,hello");
            System.out.println(s==ss);\\false
        以上结果为false，在Java中对字符串进行比较多使用strA.equals(strB)来实现
            System.out.println(s.equals(ss));\\true
        ==和equals的区别？
            ==进行数值的比计较，如果用于对象，比较的是两个内存的地址是否相同
            equals是类所提供的一种比较方法，可以直接进行字符串内容的比较
    String字符串常量
        任何使用“”定义的常量都是实现的String 类的匿名对象
        在对字符串进行比较时，一般时间字符串常量写在equals前
        假设写在后面，当比较对象为空时，会报错空指针错误
                String sss = null;
                System.out.println(sss.equals("keran"));
                Exception in thread "main" java.lang.NullPointerException
                    at testString.JavaDemo.main(JavaDemo.java:13)
        写在后面则可以规避这种错误
                System.out.println("keran".equals(sss));
    String 对象池
        对象池的使用主要是为了实现数据的共享。
        静态常量池：程序在加载的时候，会自动将字符串，普通常量，类和方法的信息等等进行分配
        运行时变量池：当一个程序加载时，可能存在的一些变量。
                String strA = "hello,keran";
                String strB = "hello," + "keran";
                System.out.println(strA == strB);//true
        静态常量池在加载时，会自动实现字符串的连接，然后入池
                String str = "keran";
                String strA = "hello,keran";
                String strC = "hello,"+str;
                System.out.println(strA == strC);//false
        程序加载时并不确定str的内容，会认为其是变量。
    String 字符串内容不可修改
        因为String包含的是一个数组，数组的长度在定义时，就开辟好了内存，且开辟的内存是固定的。
            String s1 = "hello ";
            s1 += "keren";
            System.out.println(s1);
            以上过程只是改变s1的应用，并没有对字符串进行修改，且整个过程会产生垃圾。
    String类的常用方法：
        字符串和字符操作：
            String​(byte[] bytes)
            String​(char[] value)
            public char[] toCharArray​()
            public char charAt​(int index)
                public static boolean isNumber(String str){
                    char [] result = str.toCharArray();
                    for(char ch:result){
                        if (ch<0 ||ch>0)return false;
                    }
                    return true;
                }
        字符串和字节操作：
            String​(byte[] bytes)
            public byte[] getBytes​(String charsetName)
                            throws UnsupportedEncodingException
        字符串比较：
            public boolean equals​(Object anObject)
            public boolean equalsIgnoreCase​(String anotherString)
            public int compareTo​(String anotherString)
        字符串替换：
            public String replaceAll​(String regex,String replacement)
        字符串拆分：
            public String[] split​(String regex)
            public String[] split​(String regex,int limit)
        字符串截取：
            public String substring​(int beginIndex)
            public String substring​(int beginIndex,int endIndex)
        字符串格式化：
            public static String format​(String format,Object... args)

    Java Doc文档
        类的完整定义
        类的相关说明
        类的成员属性
        类的构造函数
        类中的方法说明以及详细解释
    Java主函数的组成分析：
        public static void main(String[] args)
        public:描述的是一种权限，主方法是所有的开始点，必须公开
        static:程序的执行是通过类的名称进行完成的，表明此方法是由类直接调用的
        void：主方法是起点，没有返回
        main：系统自定义的方法名称
        String[] args：字符串数组

59 继承
继承：扩充已有类的功能，在已有类的基础上进行扩充
良好的代码风格：结构性合理，适用于维护，可重复性强。
继承实现的目的：子类可以重用父类的结构，同时也强调了功能的扩充。
虽然类的概念可以解决结构性的问题，但是会出现大量的重复代码，此时需要考虑类之间的关系问题。
    继承的实现：
        class 子类(派生类) extends 父类（超类）
        继承实现的主要目的是子类可以重用父类中的作用，并且可以实现功能的扩充。
        内存分析
        ====
        pic8
        ===
    子类对象实例化：
        在对子类对象进行实例化时，一定要先实例化父类对象
        public class Person1 {
            public Person1(){
                System.out.println("一个父类实例化对象产生");
            }
        }

        public class Student1 extends Person1{
            public Student1(){
                System.out.println("一个子类实例化对象产生");
            }
        }
        执行 new Student1();
        结果：
            一个父类实例化对象产生
            一个子类实例化对象产生
        即使没有父类对象的实例化，系统也会自己调用父类的构造方法（实例化父类）
        实际上相当于子类的构造方法隐含super（）,表示子类构造调用父类构造，并且放在首行。
        super（）相对于调用父类的无参构造，但是当父类中没有无参构造时，就必须利用super明确调用有参构造。
        public class Person1 {
            private String name;
            public Person1(String name){
                this.name = name;
            }
        }
        public class Student1 extends Person1{
            private String school;
            public Student1(String name ,String school){
                super(name);
                this.school = school;
            }
        }
        执行
        new Student1("keran","tongji");
        在实例化子类对象的同时一定要实例化父类对象
    继承的相关限制：
        Java中不允许多重继承，可以多层继承，但层次不该超过3层
            class A extends B,C(多重继承)
            class B extends A class C extends B(多层继承)
        对于私有操作属于隐式继承，非私有属于显式继承
            class A{
                private String name;
                public getName(){
                    return name;
                }
            }
            class B extends A{
                public B(String name){
                    this.name = name;
                }
                public void fun(){
                    System.out.printIn(getName())
                }
            }
            执行
            A a = new A("a");
            a.fun()
63 方法覆写
    子类可以继承父类中的所有方法，但是有些被继承的方法不适合直接应用。
    对于需要保留父类中的方法或者属性名称的情况下就会发生覆写。
        方法覆写的实现：
            方法覆写：子类中的方法和父类中的完全一样，方法名，参数个数类型完全一致。
            package testOverride;

            public class Channel {
                public void connect(){
                    System.out.println("父类进行资源链接");
                }
            }

            public class DatabaseChannel extends Channel {
                public void connect(){
                    System.out.println("子类进行数据库进行链接");
                }
            }

            public class JavaDemo {
                public static void main(String[] args) {
                    DatabaseChannel channel = new DatabaseChannel();
                    channel.connect();
                }
            }
            由于实例化的是子类对象，所以调用方法一旦被覆写则调用覆写后的内容，否则将调用父类方法。
            覆写的意义在于优化父类的功能.
            由子类调用父类方法，需要添加super
                public void connect(){
                    super.connect();
                    System.out.println("子类进行数据库进行链接");
                }
        方法覆写的限制：
            public>default>private。覆写的方法权限必须更高。
            父类中的方法使用了default，子类只能是public或者default
            父类中的方法使用了public，子类只能是public
            父类中的方法使用了private,则不涉及覆写方法。
        覆写和重载的区别：
            1         重载                      覆写
            2   方法名相同，参数类型和个数不用    方法完全一致
            3      无权限限制                        有限制权限
            4      发生在一个类中                     发生在继承中
        super和this的区别：
            1          this                                        super
            2      使用this先从本类中查找所需要的属性或者方法       直接查找父类
                   本类不存在则从父类中调用
            3       本类构造方法                                   父类构造方法
            4        可以表示本类当前对象
        final关键字：
            终结器的概念，在Java中使用final关键字实现不能被覆写的类，不能被覆写的方法和常量
            当父类中的某些方法不希望被子类覆写，则在方法前加final
            在某些系统开发中，不希望某些属性被改变，则加final修饰关键字表示常量。
            使用public static final定义全局常量，常量名大写。

71 注解
   ·Annotati注解，以注解的形式实现程序开发
        在程序中定义所有需要用到的资源
        在配置文件中定义资源（配置内容较少）
        利用注解将代码和资源分割
   ·@Override 在明确覆写方法上写，帮助检测错误
   ·@Deprecated 过期声明。在开发过程中，新版本和老版本的不适应，不再建议使用的方法
   ·@SuppressWarning 压制警告
 75 多态
    ·基本概念
        多态在继承性基础之上扩展出来的概念，可以实现父子类之间的互相转化
        方法多态性：
            重载：同一个方法根据不同的参数实现功能
            覆写：同一个方法根据类的不同，执行不同功能
        对象的多态性：
            对象向上转型：父类 实例 = 子类实例（自动转化）
            对象向下转型：子类 实例 = （子类）父类实例（强制转换）
    ·对象向上转型
        对象转型属于多态性，建立在继承的基础上
        Message msg = new DatabaseMessage();
        向上转型：可以对参数进行统一设计
        public static void main(String[] args) {
            fun(new DatabaseMessage());
            fun(new WebServeMessage());
        }
        public static void fun(Message msg){
            msg.print();
        }
    ·instanceof关键字
        对象 instanceof 类  返回boolen型
79 Object类
    ·基本概念：
        解决参数统一的问题
        Object类不存在继承关系,该类提供无参构造方法。
        Object是所有类的父类，则可以用Object接收所有类（也可以接收数组）
    ·方法：
        toString():获取对象的信息，一般都会覆写
            System.out.println(per);
            System.out.println(per.toString());
        equals():对象比较，比较两个对象的内容是否完全一致。
            对象的比较应该在类的外部进行，默认情况是比较两个对象的地址。
            @Override
            public boolean equals(Object obj) {
                // 空对象不比较
                if (obj == null) return false;
                // 只比较同类对象
                if (! (obj instanceof Person)) return false;
                // 目的是为了获取类中的属性
                Person per = (Person) obj;
                return this.name.equals(per.name) &&
                        this.age == per.age;
            }
82 抽象类
    ·基本概念：
        在对父类的设计时，优先考虑抽象类。抽象类的主要作用是对子类中覆写方法的约定，在抽象类总可以定义抽象方法以实现该约定。
        抽象方法：利用abstract关键字定义，抽象方法的所在的类必须是抽象类。
    · 抽象类的实现：
        abstract class Message {
            private String type;
            public abstract String getConnectInfo();
            public void setType(String type){
                this.type = type;
            }
            public String getType(){
                return this.type;
            }
        }
        抽象类不可以直接new对象，抽象类的实现原则：
            抽象类必须有子类，子类使用extends继承抽象类
            抽象类的子类一定要覆写抽象类中的全部抽象方法
            抽象类的对象实例化可以利用对象的多态性通过子类向上转型的方式完成。
                public static void main(String[] args) {
                    Message msg = new DatabaseMessage();
                    System.out.println(msg.getConnectInfo());
                }
    ·相关说明：
        抽象类不可以使用final进行定义；
        抽象类是普通类的加强出现，抽象类也包含属性的定义和构造函数的使用。
        抽象类中可以没有抽象方法，但也不可以通过new实例化对象。
        static方法不受实例化对象或者结构的限制，可以通过类名进行调用。
    ·模板设计模式：
        对子类方法进行统一管理
        自身提供一些普通方法供自身使用
85包装类
    ·基本概念：基本数据不属于一个类，包装类将基本数据类型包装成类。
        public static void main(String[] args) {
            // 装箱：将基本数据类型保存在包装类之中
            Object obj = new Int(10);
            // 拆箱：从包装类对象中获取基本数据类型
            int x = ((Int)obj).intValue();
            System.out.println(x*2);
        }
        基本数据进行包装后，可以像对象一样进行应用传递。
        基本数据类型      包装类
           int             Integer
           byte             Byte
           short            Short
           long             Long
           float            Float
           double           Double
           boolean          Boolean
           字符             Character
    ·装箱和拆箱：
        Integer o = new Integer(10);//装箱
        int data = o.intValue();//拆箱
        System.out.println(data);

        Integer o1 = 10;   //自动装箱
        int num = o1;      //自动拆箱
        o1++;              //包装类对象可以直接参与数学运算
        System.out.println(num * o1);//直接参与数学运算
        包装类的相等判断应该使用equals（）完成，包装类也要考虑占位长度。
87接口
    ·基本定义：
        抽象类和普通类的优势：可以实现对子类覆写的控制，但抽象类中有些普通方法
        可能会涉及到安全和隐私的问题，如果想要对外部隐藏全部的实现细节，则可以使用接口。
        接口可以理解成一个纯粹的抽象类（只包含抽象方法和全局常量）。
        在Java中以Interfae来定义，接口的使用原则：
            接口需要被子类实现，一个子类可以实现多个父接口
            子类一定要覆写接口中的全部抽象方法
            接口对象利用子类对象的向上转型进行实例化
        interface iMessage {
            public static final String INFO = "aaa";//全局常量
            public abstract String getInfo();//抽象方法
        }
        public class MessageImpl implements iMessage {
            public String getInfo(){
                return "hahaha";
            }
        }
        public static void main(String[] args) {
            iMessage msg = new MessageImpl();
            System.out.println(msg.getInfo());
            System.out.println(iMessage.INFO);
        }

        在Java里面之所以使用接口的目的是一个子类可以实现多继承的概念
        子类实现多个父接口:
        public class MessageImpl implements IMessage,IChannel {
            public String getInfo(){
                if(connect()){
                    return "得到消息";
                }
                return "没有得到消息";
            }
            public boolean connect() {
                System.out.println("通道成功建立");
                return true;
            }
        }
        接口描述的是一个公共的定义标准，在接口之中所有的抽象方法的访问权限都为public

        子类继承抽象类并实现父接口
        public class MessageImpl extends DatabaseAbstract implements IMessage,IChannel {
            public String getInfo(){
                if(connect()){
                    if (getDatabaseConnection()){
                        return "数据库连接成功，得到消息";
                    }else{
                        return "无法获取数据库";
                    }
                }
                return "没有得到消息";
            }
            public boolean connect() {
                System.out.println("通道成功建立");
                return true;
            }

            @Override
            public boolean getDatabaseConnection() {
                return true;
            }
        }
        接口多继承：虽然接口无法继承一个父类，但是一个接口可以通过extends继承若干个父接口
        public interface IServer extends IMessage,IChannel {
            public abstract String server();
        }
    ·接口定义加强
        为了方便子类的修改，，一般不会让子类直接实现接口，而是在中间加一过渡的抽象类
    ·工厂设计模式
        对于接口而言，必须有子类，并且子类可以通过对象的向上转型来获取接口的实例化对象
        public class Factory {
            public static IFood getInstace(String classNmae){
                if ("bread".equals(classNmae)){
                    return new Break();
                }else{
                    return null;
                }
            }
        }
    ·代理设计模式
        将开发得到注意力集中在核心业务功能处理上
    ·抽象类和接口的区别：
        抽象类：abstract 抽象类名称{}
            构造方法，普通方法，全局常量，static方法，静态方法
            任意权限
            子类通过extends只能继承一个抽象类
            抽象类可以实现若干个接口
        接口：interface 接口名称{}
            抽象方法，全局常量，static
            public
            子类通过implements继承多个接口
            接口不允许继承抽象类，但是可以继承多个父接口

        使用：抽象类和接口必须定义子类
              子类一定要覆写抽象类或者接口中的全部抽象方法
              通过子类的向上转型实现实例化
        当两者都可以使用时，优先考虑接口（可以避免单继承的限制）
96 泛型
    ·基本定义
        Java期望通过泛型解决ClassCastException。
        泛型的本质：类中的属性或者方法的参数与返回值的类型可以由对象实例化决定
            public class Point <T>{
                private T x;
                private T y;

                public T getX() {
                    return x;
                }

                public void setX(T x) {
                    this.x = x;
                }

                public T getY() {
                    return y;
                }

                public void setY(T y) {
                    this.y = y;
                }
            }

            Point<Integer> point1 = new Point<Integer>();
            point.setX(10);
        泛型值允许设置引用类型，如果操作基本数据类型必须使用包装类
    ·泛型通配符
        如果不设置泛型，那么在方法中就可能会对数据进行修改，因此提出泛型，可以接受所有的内容，但不修改
        里面的数据，使用通配符“？”来实现。
            ? extends 类：设置泛型的上限，只能使用其本身或者其子类
            ？super 类：设置泛型的下限，只能使用其本身或者其父类。

    ·泛型接口
        public class MessageImpl<S> implements IMessage<S> {
            @Override
            public String echo(S s) {
                return "echo"+s;
            }
        }
101 包
    ·包的定义
        不同的目录下可以存放相同的名称，此时目录可以理解成包
        打包编译：javac -d.类名.java
        执行：java 包.类名
    ·包的导入
        package testPackage.alibaba.test;
        import testPackage.alibaba.util.Message;
        public class TextMessage {
            public static void main(String[] args) {
                Message msg = new Message();
                msg.getContent();
            }
        }
        当使用一个包中的很多类时，使用*来表示，但不表示全部的加载，而是加载需要被导入的类。
    ·系统常见包
        java.lang:String 、Number
        java.lang.reflect:反射机制
        java.util:工具类的定义
        java.io:输入输出流操作
        java.net:网络程序开发的程序包
        java.applet:直接嵌套在网页上执行的程序
        java.awt:java的图像界面界面开发包
    ·访问控制权限
        同一包中的同一个类：private  default protected public
        同一包中不同的类：           default protected public
        不同包的子类：                       protected public
        不同包的所有类：    public
107 类图
    ·概念：
        UML统一建模语言，利用图形化的形式来实现程序类关系的描述。
        类的描述：    类名称-属性-方法（抽象类斜体描述）
        其中属性带权限描述   public（+），protected（#），private（-）
108 单例设计模式
    ·单例设计
        由于某些情况，要求该类只允许一个实例化对象，此时应该控制构造方法
        因为新的实例化对象的产生一定会经过构造方法。
        public class Singleton {
            private static final Singleton INSTANCE = new Singleton();
            public static Singleton getInstance(){
                return INSTANCE;}
            private Singleton(){}
            // 私有构造方法
            public void print(){
                System.out.println("aaa");
            }
        }
        public static void main(String[] args) {
            Singleton instance = null;
            instance = Singleton.getInstance();
            instance.print();
        }
        在一些情况下，如果程序启动，那么现在肯定需要一个类负责保存程序的加载信息。
        特点：
            构造方法私有化
            类的内部提供static方法获取实例化对象
    ·多例设计
        package textSingleton;

        public class Color {
            public static final Color RED =new Color("RED");
            public static final Color YELLOW =new Color("YELLOW");
            public static final Color BLUE =new Color("BLUE");
            private String title;
            private Color(String title){
                this.title = title;
            }
            public static Color getInstance(String color){
                switch(color){
                    case "red" :return RED;
                    case "yellow" :return YELLOW;
                    case "blue" :return BLUE;
                }
                return null;
            }

            @Override
            public String toString() {
                return this.title;
            }
        }

        Color c = Color.getInstance("red");
        System.out.println(c.toString());
        多例设计和单例设计类似，都是在内提供static方法以返回实例化对象。

112 枚举
    ·定义
        枚举用于定义有限个数的对象，属于多例设计模式
        public enum Color {
            RED,GREEN,YELLOW;
        }
        public static void main(String[] args) {
            Color c = Color.RED;
            System.out.println(c);

            for (Color color: Color.values()){
                System.out.println(color);
            }
        }
    ·Enum类
        enum和Enum关系
        enum:关键字，用于定义枚举类
        Enum：抽象类，使用enum定义的类就默认继承此类
    ·定义枚举结构
        public enum Color {
            RED("red"),GREEN("greeb"),YELLOW("yellow");
            private String title;
            private Color(String title){
                this.title = title;
            }
            public String toStrint(){
                return this.title;
            }
        }
116 异常
    ·基本定义
        导致程序中断执行的一种指令流,当程序错误后，整个程序不会按照既定的方式进行执行，而是中断了执行。
        public static void main(String[] args) {
            System.out.println("程序开始");
            System.out.println("程序计算："+(10/0));
            System.out.println("程序结束");
        }
        Exception in thread "main" java.lang.ArithmeticException: / by zero
        	at testException.JavaDemo.main(JavaDemo.java:6)
        为了保证程序出现了非致命错误之后，还可以正常完成程序功能。
    ·异常处理
        try{
            //可能出现的异常语句
        }[ catch（异常类型 异常对象）{
            //异常处理
        }]finally{
            //无论是否异常都会执行。
        }

        public static void main(String[] args) {
            System.out.println("程序开始");
            try {
                System.out.println("程序计算：" + (10 / 0));
            }catch (ArithmeticException e){
                System.out.println("异常对象："+e);
            }
            System.out.println("程序结束");
        }
        如果要获取完整的异常信息，则可以使用printStackTrace()。
        e.printStackTrace();
        java.lang.ArithmeticException: / by zero
        	at testException.JavaDemo.main(JavaDemo.java:7)
    ·处理多个异常
        如果程序中的没有正确捕获，也会影响代码的运行
        import testWrapper.Int;

        public class JavaDemo {
            public static void main(String[] args) {
                System.out.println("程序开始");
                try {
                    int x = Integer.parseInt(args[0]);
                    int y = Integer.parseInt(args[1]);
                    System.out.println("程序计算：" + (x / y));
                }catch (ArithmeticException e){
                    e.printStackTrace();
                }catch (NumberFormatException e){
                    e.printStackTrace();
                }catch (ArrayIndexOutOfBoundsException e){
                    e.printStackTrace();
                }
                System.out.println("程序结束");
            }
        }
    ·异常处理流程
        1、在程序运行过程中产生异常，一旦产生异常以后将自动进行指定类型的异常类对象实例化处理。
        2、如果没有异常处理的支持，则打印异常信息，退出当前程序
        3、如果有异常处理的支持，产生的异常类实例化对象将被try语句捕获
        4、try捕获到异常之后与catch中的异常依次进行比对，若没有匹配成功，该异常无法进行处理
        5、不管时候执行异常处理，都会执行finally语句，但执行完finally的程序后进一步判断当前异常是否处理：
            如果处理过了：则继续先后执行
            如果没有处理：交由JVM继续处理。
        对于 ArrayIndexOutOfBoundsException的继承关系
            java.lang.Object
                java.lang.Throwable
                    java.lang.Exception
                        java.lang.RuntimeException
                            java.lang.IndexOutOfBoundsException
                                java.lang.ArrayIndexOutOfBoundsException
        Throwable的异常子类：
            Error:程序中还没有执行时出现的错误，开发者无法处理
            Exception：程序中出现的异常，开发者可以处理
        异常产生的时候产生异常的实例化对象，按照对象的应用原则，可以直接向父类（向上）转型
    ·throws和throw
        throws：假设在定义方法时，应该告诉使用者这个方法可能产生什么样的异常，可以使用throws关键字进行异常类型的标注
                public static int div(int x,int y) throws Exception{
                    return x/y;
                }
                会报错：Error:(22, 38) java: 未报告的异常错误java.lang.Exception; 必须对其进行捕获或声明以便抛出
                应该        try {
                              System.out.println(MyMath.div(10, 2));
                          } catch (Exception e) {
                              e.printStackTrace();
                          }
        throws：在方法定义中使用，表示该方法可能产生的异常明确告诉调用处
        throw：手动抛异常，在代码块中使用
    ·RuntimeException
        对于NumberFormatExceptio类的继承
        java.lang.Object
            java.lang.Throwable
                java.lang.Exception
                    java.lang.RuntimeException
                        java.lang.IllegalArgumentException
                            java.lang.NumberFormatExceptio
        RuntimeException标注的异常可以不进行处理
123 内部类
    ·基本概念
        内部类：在一个类的内部定义其他的类，独立且完善的一个结构。
        public class Outer {
            private String msg = "aaa";
            public void fun(){
                Inner inner = new Inner();
                inner.print();
            }
                class Inner{
                    public void print(){
                        System.out.println(Outer.this.msg);
                    }
                }
        }
        public static void main(String[] args) {
            Outer out = new Outer();
            out.fun();
        }
        内部类的提出优势：
            可以轻松的访问外部类中的私有属性
            外部类也可以访问内部类的私有属性
        内部类实例化对象的格式：
            外部类.内部类 内部类对象 = new 外部类（）.new 内部类（）；
            Outer.Inner in = new Outer().new Inner();
        抽象类和接口也可以定义内部类
        public class ChannelImpl implements IChannel {
            @Override
            public void send(IMessage msg) {
                System.out.println(msg.getConnect());
            }
            class MessageImpl implements IMessage{
                @Override
                public String getConnect() {
                    return "aaa";
                }
            }
        }
    ·static 定义内部类
        static定义的内部类相当于独立的类，该类结构相当于独立类。
        static定义的不管是类还是方法都只能访问static成员
            public class Outer {
                private static final String MSG = "aaa";

                static class Inner{
                        public void print(){
                            System.out.println(Outer.MSG);
                        }
                    }
            }
            public static void main(String[] args) {
                Outer.Inner in = new Outer.Inner();
                in.print();
            }
            实例化对象：
            外部类.内部类 内部类对象 = new 外部类.内部类（）
    ·在方法中定义内部类
        public class Outer {
            private static final String MSG = "aaa";

            static class Inner{
                    public void print(){
                        System.out.println(Outer.MSG);
                    }
                }
        }
        内部类可以直接方法外部类的私有属性，也可以访问传入参数。
    ·匿名内部类
        简化的内部类处理形式,一些接口的子类只要一个，以匿名内部类代替
        IMessage msg = new IMessage(){
            public void send(String str){
                System.out.println(str);
            }
        };
        msg.send("keran");
        在接口内部定义匿名内部内
        public interface IMessage {
            public void send(String msg);
            public static IMessage getInstance(){
                return new IMessage() {
                    @Override
                    public void send(String msg) {
                        System.out.println(msg);
                    }
                };
            }
        }
        匿名内部类和普通内部类相比较是一个没有名字的，只够使用一次的并且结构固定的子类。

131 Lambda
    ·定义
        简化函数的代码开发，利用函数式编程可以避免面向对象中的繁琐问题
        SAM(single abstract method )原则：只有一个抽象方法，只有函数式接口才可以被Lambda表达
        Lambda格式：
            方法无参数：（）->{}
                public static void main(String[] args) {
                    IMessage msg = ()->{
                        System.out.println("hello,keran ");
                    };
                    msg.send();
                }
            方法有参数：（参数，参数）->{}
                IMath math = (t1,t2)->{
                            return t1+t2;
                        };
                        System.out.println(math.add(1,4));
            方法只有一行返回语句：（参数，参数）->语句
                 IMath math = (t1,t2)-> t1+t2;
            利用Lambda可以摆脱传统面向对象关于结构的限制，简化代码
    ·方法引用
        引用数据类型最大的特点是可以进行内存的指向处理，不同的方法名称可以描述同一方法
            引用静态方法：类名称::static方法名称
                public interface IFunction<P,R> {
                    public R change(P p);
                }
                IFunction<Integer,String> fun = String::valueOf;
                String str = fun.change(100);
                System.out.println(str.length());
                利用方法引用可以为一个方法定义多个名字
            引用某个实例化方法：实例化对象::普通方法
               IFunction<String> fun = "aaa"::toUpperCase;
            引用特定类型的方法：特定类::普通方法
                IFunction<String> fun = String::compare;
            引用构造方法：类名称::new
                IFunction<Person> fun = Person::new;
    ·内建函数式接口
        java.util.functio开发包中常见接口
            功能形函数式接口：public R apply(T t)
                Function<String,Boolean> f1 = "hello"::startsWith;
                System.out.println(f1.apply("h"));
            消费形函数式接口：public void accept(T t)
                Consumer<String> f2 = System.out::println;
                f2.accept("hello");
            供给形函数式接口：public T get()
                Supplier<String> f3 = "hello"::toUpperCase;
                System.out.println(f3.get());
            断言形函数式结构：public boolean test(T t)
                Predicate<String> f4 = "hello"::equalsIgnoreCase;
                System.out.println(f4.test("HeLLo"));


2 进程与线程
    ·进程和进程
        进程（在操作系统上的划分）
            单进程：在同一时间只允许执行一个进程
            多进程：在同一个时间，允许执行多个程序，进行资源的轮流抢占。
        线程（在进程上的划分）
            在进程基础上划分的更小的程序单元，线程是在进程基础上创建使用的，线程依赖进程的支持，
            线程的启动速度要比进程快很多
    ·Thread类：
        在Java中专门的线程主体类进行线程的执行任务的定义，必须实现特定的接口或者继承特定的父类
        继承Thread类实现多线程：一个类只要继承了此类就表示这个类为线程的主体类，但是还需要覆写run（）方法。
        多线程要执行的方法都在run中定义
        public class Mythread extends Thread {
            private String title;
            public Mythread(String title){
                this.title = title;
            }
            @Override
            public void run() {
                for (int i = 0;i<10;i++){
                    System.out.println(this.title+":"+i);
                }
            }
        }
        run方法不可以通过实例化对象的调用，必须使用start()方法。
            new Mythread("线程A").run();
            new Mythread("线程B").run();
            会按照顺序执行，没有多线程执行
            new Mythread("线程A").start();
            new Mythread("线程B").start();
            new Mythread("线程C").start();
            会按照线程执行，但顺序不可控。
        在start()方法中会抛出IllegalThreadStateException()，每一个线程类只能启动一次，重复启动会抛出该异常
        start()方法中调用了start0()函数
            start0()中的关键字native，表示可以直接调用操作系统底层函数。
    ·Runnable接口
        避免Thread单继承的缺陷。
        public class Mythread1 implements Runnable {
            private String title;
            public  Mythread1(String title){
                this.title = title;
            }
            @Override
            public void run() {
                for(int i =0;i<10;i++){
                    System.out.println(this.title+":"+i);
                }
            }
        }
        Thread threadA = new Thread(new Mythread1("runnableA接口"));
        Thread threadB = new Thread(new Mythread1("runnableB接口"));
        Thread threadC = new Thread(new Mythread1("runnableC接口"));
        threadA.start();
        threadB.start();
        threadC.start();

        Runnable接口使用了函数式接口定义，也可以直接使用Lambda表达式进行线程类的定义
        for(int x = 0;x<3;x++){
            String title = "线程对象-"+x;
            Runnable run = ()->{
                for (int y = 0 ;y<10;y++){
                    System.out.println(title+":"+y);
                }
            };
            new Thread(run).start();
        }
    ·Thread和Runnable接口关系
        Thread类也是Runnable接口的子类，继承Thread类后覆写的还是Runnable的run方法。
        多线程的设计中，使用代理设计模式，用户自定义有线程主体只是负责项目核心功能的实现，而辅助任务交由Thread类来实现
        在进行Thread启动多线程的时候，调用的是start()方法，而后找到run方法。
            Thread类的构造方法传递的是Runnable接口对象，那么该接口对象将被Thread类中的target属性所保存，start(）方法在执行时会
        调用run()方法，而run方法调用Runnable接口子类被覆写的run（）方法
        多线程开发的本质是多个线程可以对统一资源进行抢占。Thread主要描述的是线程，Runnable主要描述的是资源
    ·callable实现多线程
        Runnable接口的缺陷：无法获取一个返回值。
    ·多线程运行状态
        1.任何一个线程的对象都应该使用Thread类进行封装，所有线程的启动都是用start()，但是启动的时候，若干个进程都处于一种就绪
        状态，并没有执行
        2.进入到就绪状态之后就需要等待进行资源的调度，当某个线程调度成功之后进入到运行状态（run()）,所有线程不可能一直处于执
        行状态，中间会产生一些暂停的状态，例如：当某个线程执行一段时间后就需要让出资源，进入阻塞状态，随后重新进入就绪状态。
        3.run()方法执行后，实际上该线程的主要任务也将结束，此时直接进入到停止状态。
    ·多线程操作方法
        都定义在Thread类中。
            获取当前线程名称：Thread.currentThread().getName();
            任何主线程都可以创建若干个子线程，目的在于将复杂的或者耗时的逻辑交给子线程处理。
                System.out.println("执行耗时流程");
                new Thread(() -> {
                    int temp = 0;
                    for (int x = 0; x < Integer.MAX_VALUE; x++) {
                        temp += x;
                    }
                }).start();
                System.out.println("执行后续任务");
